/* eslint-env node */
/* eslint-disable no-console */
// NOTE: This file is run pre build and creates `pages.js`.
const chalk = require('chalk');
const fs = require('fs');
const klaw = require('klaw');
const kebabToPascal = require('@creuna/utils/kebab-to-pascal').default;
const path = require('path');
const prettier = require('prettier');

const prettierConfig = require('./prettier-config');
const pagesDirectory = path.join(__dirname, '..', 'source', 'mockup', 'pages');

const disclaimers = [
  '// NOTE: Do not edit this file. It is built by running `./build/create-mockup-pages.js`',
  `// NOTE: Generated at ${new Date().toISOString()}`
];

const fileName = 'pages.js';

console.log(`⚙️  Generating ${chalk.blueBright(fileName)}`);

const pages = {};

const filter = item => {
  const basename = path.basename(item);
  return basename === '.' || basename[0] !== '.';
};

klaw(pagesDirectory, { filter })
  .on('readable', function() {
    let item;
    while ((item = this.read())) {
      const slugs = item.path.split(path.sep);
      const indexFile = `${slugs
        .filter((item, index) => {
          return index !== slugs.length - 1;
        })
        .join(path.sep)}${path.sep}index.js`;
      const fileName = slugs[slugs.length - 1].replace('.jsx', '');
      const folderName = slugs[slugs.length - 2];

      if (fileName === folderName && fs.existsSync(indexFile)) {
        const componentName =
          folderName[0] === folderName[0].toUpperCase()
            ? folderName
            : kebabToPascal(slugs[slugs.length - 2]);

        const fileContent = fs.readFileSync(item.path, { encoding: 'utf-8' });
        const firstLine = fileContent.split(/(?:\r\n|\r|\n)/g)[0];
        const hasPageName = firstLine.search(/^\/\//) !== -1;
        const pageDescription = hasPageName
          ? firstLine.replace(/^\/\/\s?/, '').split('/')
          : componentName;
        const hasGroupName = pageDescription.length === 2;
        const pageName = hasGroupName ? pageDescription[1] : pageDescription[0];
        const groupName = hasGroupName ? pageDescription[0] : null;

        pages[componentName] = {
          component: componentName,
          groupName: groupName,
          name: pageName,
          path: `.${item.path
            .replace(pagesDirectory, '')
            .replace(`${path.sep}${slugs[slugs.length - 1]}`, '')}`,
          url: '/' + folderName
        };
      }
    }
  })
  .on('error', (err, item) => {
    console.log(
      `👻  ${chalk.red('Error walking directory on item:')} ${chalk.blueBright(
        item
      )}`,
      err
    );
    throw err;
  })
  .on('end', () => {
    const pageGroups = Object.keys(pages)
      .reduce((accum, key) => {
        // Convert to array
        return accum.concat(pages[key]);
      }, [])
      .reduce((accum, page) => {
        // Transform into groups, based on group name
        const { groupName } = page;
        const group = accum.find(g => g.title === groupName);

        if (group) {
          group.pages.push(page);
        } else {
          accum.push({
            title: groupName,
            pages: [page]
          });
        }

        return accum;
      }, [])
      .map(group => {
        // Set fallback group name
        if (!group.title) {
          group.title = 'Annet';
        }

        group.pages = group.pages.sort((a, b) => a.name > b.name);

        return group;
      })
      .sort((a, b) => a.title > b.title);

    const importStatements = pageGroups
      .reduce((accum, group) => accum.concat(group.pages), [])
      .reduce((accumulator, page) => {
        accumulator += `import ${page.component} from '${page.path}';\n`;
        return accumulator;
      }, '');

    const exportContent = pageGroups.reduce((accum, group, groupIndex) => {
      const separator = groupIndex < pageGroups.length - 1 ? ',' : '';
      const pagesContent = group.pages.reduce(
        (accumulator, page, pageIndex) => {
          const separator = pageIndex < group.pages.length - 1 ? ',' : '';
          accumulator += `  {
            component: ${page.component},
            name: '${page.name}',
            url: '${page.url}'
          }${separator}\n`;

          return accumulator;
        },
        ''
      );

      accum += `{
          title: '${group.title}',
          pages: [${pagesContent}]
        }${separator}\n`;

      return accum;
    }, '');

    const exportStatement = `export default [\n${exportContent}];`;

    const fileContent = `${disclaimers.join('\n')}\n${importStatements.replace(
      /\\/g,
      '/'
    )}\n${exportStatement}\n`;

    fs.writeFile(
      path.join(__dirname, '..', 'source', 'mockup', 'pages', fileName),
      prettier.format(fileContent, prettierConfig),
      {},
      err => {
        if (!err) {
          console.log(`💾  ${chalk.blueBright(fileName)} saved`);
        } else {
          console.log(
            `👻  ${chalk.red('Error writing')} ${chalk.blueBright(fileName)}`,
            err
          );
        }
      }
    );
  });
